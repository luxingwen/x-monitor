# Linux内核抢占（preempt）

## 进程调度

2.6内核为提高对交互程序的调度性能引入了新的进程调度算法。最著名的是“反转楼底最后期限调度算法”（RSDL），该算法吸取了队列理论，将公平调度的概念引入了Linux调度程序。在2.6.23内核版本被称为“完全公平调度算法”（CFS）。

## 上下文切换

**从一个可执行进程切换到另外一个可执行进程**。每当一个新的进程被选出来准备投入运行的时候，schedule()就会调用context_switch()函数。它完成两项基本工作：

1. 调用switch_mm，负责把虚拟内存从上一个进程映射切换到新进程中。
2. 调用switch_to，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，都必须以每个进程为对象进行管理和保存。

### 调用schedule函数时机

如果仅靠用户程序代码显示的调用schedule，那么用户进程可能会永远的执行下去。相反，内核提供了一个need_resched标志来表明是否需要重新执行一次调度。

何时设置这个标志：

- 当某个进程应该被抢占时，scheduler_tick()就会设置这个标志。
- 当一个优先级高的进程进入可执行状态的时候，try_to_wake_up也会设置这个标志。

该标志对于内核来讲就是一个信息，它表示有其他进程应当被运行了，**要尽快调用调度程序**。

在返回用户空间以及从中断返回的时候，内核也会检查need_resched标志。如果已被设置，内核会在继续执行之前调用调度程序。

## 抢占

内核抢占是指用户程序在执行系统调用期间可以被抢占，该进程暂时挂起，使新唤醒的高优先级进程能够运行。

这种抢占并非可以在内核的任意位置都能安全进行，比如在**临界区中的代码**就不能发生抢占。

临界区：是指同一时间内该指令序列只能有一个进程在执行。

内核抢占要求内核中所有可能为一个以上进程共享的变量和数据结构都要通过互斥机制加以保护，都要梵高临界区中。

### 不可抢占内核的特点

在不支持内核抢占的内核中，内核代码可以一直执行，到它完成为止。

调度程序没有办法在一个内核级的任务正在执行的时候重新调度—内核中的各任务是协作方式调度的，不具备抢占性。

当然，运行于内核态的进程可以主动放弃CPU，比如，在系统调用服务例程中，由于内核代码由于等待资源而放弃CPU，这种情况叫做计划性进程切换（planned process switch）。

考虑单CPU的情况，这样大大的简化内核的同步和保护机制。

- 不考虑进程在内核中自愿放弃CPU的情况。一旦进程进入内核就将一直运行下去，直到完成或退出内核。在其没有完成或退出内核之前，不会有另外一个进程进入内核，即进程在内核中执行是串行的，不可能有多个进程同事在内核中运行。这样内核代码就不用考虑多个进程同时执行所带来的并发问题。

- 资源放弃CPU的情况。因为对CPU的放弃是自愿的、主动的，也就意味着进程在内核中的切换是预先知道的，不会出现在不知道情况下发生进程的切换。

### 为何需要内核抢占

首先，这是将Linux应用于实时系统所必须的。实时系统对响应时间有严格的限定，当一个实时进程被实时设备的硬件中断唤醒后，它应该在限定的时间内被调度执行。

对于那些高实时响应的系统是不能接受的。而可抢占的内核不仅对Linux的实时应用至关重要，而且能解决Linux对多媒体等要求低延迟的应用支持不够好的缺陷。

### 抢占的时机

如果内核不是一个中断处理程序中，并且不在被spinlock等互斥机制保护的临界代码中，就可以“安全”的进行进程切换。

Linux内核抢占只有在内核正在执行例外处理程序（通常指系统调用）并且允许内核抢占时，才能进行抢占内核。简而言之：

- 从系统调用返回用户空间。
- 从中断处理程序返回用户空间。

### 禁止抢占

禁止抢占的情况如下：

1. 内核执行中断处理程序时不允许抢占，中断返回时在执行内核抢占。
2. 当内核执行软终端或tasklet时，禁止内核抢占，软中断返回时在执行内核抢占。
3. 内核代码正持有spinlock、wr_lock、rd_lock锁，处于这些锁的保护状态中。内核中的这些锁是为了在smp系统中短时间内保证不同CPU上运行的进程并发执行的正确性。在临界区禁止内核抢占，临界区保护函数通过抢占计数宏控制抢占，**计数大于0**，表示禁止内核抢占。
4. 内核正在对每个CPU“私有”的数据结构操作（per-CPU data structures），在smp中，对于per-CPU数据结构未用spinlock保护，因为这些数据结构隐含被保护了（不同的CPU有不一样的per-CPU数据，其它CPU上运行的进程不会用到另一个CPU的per-CPU数据）。

### 支持内核抢占

抢占式内核实现的原理是释放自旋锁时或从中断返回时，如果当前执行进程的need_resched被标记，则进行抢占式调度。

Linux内核在线程信息结构上增加了成员preempt_count作为内核抢占锁，每当内核要进入以上几种状态时，变量preempt_count就加1，指示内核不允许抢占。当从内核从以上几种状态退出时，变量preempt_count就减一，同时进行可抢占的判断与调度。

内核调度器的入口为preempt_schedule()，它将当前进程标记为TASK_PREEMPTED状态再调用schedule()，在TASK_PREEMPTED状态，schedule()不会将进程从运行队列中删除。

## 资料

1. [Linux内核抢占机制(preempt) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/454793333)
2. [详解Linux系统中的内核抢占机制 - 程序员文章站 (superweb999.com)](https://www.superweb999.com/article/1293706.html)