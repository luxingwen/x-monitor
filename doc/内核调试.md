# 内核调试

## 准备CentoOS8环境

### 查看可用的系统内核

```
yum --enablerepo="baseos" list --showduplicates | sort -r | grep kernel
```

### 安装debug版本内核

```
dnf -y install kernel-debug
```

执行这个命令会安装以下三个包

- kernel-debug
- kernel-debug-core
- kernel-debug-modules

在boot目录下会安装+debug版本的内核，vmlinuz-4.18.0-348.7.1.el8_5.x86_64+debug。

### 安装debuginfo内核

如果是centos8版本，修改文件/etc/yum.repos.d/CentOS-Debuginfo.repo，设置enable=1，然后运行**yum install kernel-debuginfo**。

```
=======================================================================================================================================================================================================================
 Package                                                          Architecture                             Version                                                   Repository                                   Size
=======================================================================================================================================================================================================================
Installing:
 kernel-debuginfo                                                 x86_64                                   4.18.0-348.7.1.el8_5                                      debuginfo                                   596 M
Installing dependencies:
 kernel-debuginfo-common-x86_64                                   x86_64                                   4.18.0-348.7.1.el8_5                                      debuginfo                                    88 M

Transaction Summary
=======================================================================================================================================================================================================================
Install  2 Packages
```

安装完毕后，非压缩的+debuginfo的内核就存在了/usr/lib/debug/usr/lib/modules/4.18.0-348.7.1.el8_5.x86_64/vmlinux，可以用于crash调试。

```
[root@localhost /]# file /usr/lib/debug/usr/lib/modules/4.18.0-348.7.1.el8_5.x86_64/vmlinux
/usr/lib/debug/usr/lib/modules/4.18.0-348.7.1.el8_5.x86_64/vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=209f9b66ebe4f81279616bbf61396c29028bf7f8, with debug_info, not stripped
```

通过file命令可以看到：with debug_info, not stripped。

## Kdump

kdump是内核崩溃的时候，用来转存运行内存的一个工具。系统一旦崩溃，内核就没法工作了，这个时候将由kdump提供一个用于捕获当前运行信息的内核，该内核会将此时内存中的所有运行状态和数据信息收集到一个dump core文件中以便之后分析崩溃原因。一旦内存信息收集完成，可以让系统自动重启。

### 工作原理

当内核发生panic时，内核依靠kexec机制在预先保留的内存区域快速重启一个新的内核实例，预留内存区域大小可以通过内核启动参数crashkernel指定。

为了实现双内核布局，kdump在内核崩溃后立即使用**kexec引导转储捕获内核（capture kernel）**，使用kexec引导“覆盖”当前运行的内核。kexec（kernel execution）是linux内核的一种机制，其允许从当前运行的内核启动新内核。kexec会跳过由系统固件执行的引导加载程序阶段和硬件初始化阶段，直接将新内核加载到主内存并立即开始执行。

![kdump原理架构](./kdump原理架构.jpg)

![kdump-complete-flow](./kdump-complete-flow.jpg)

Kdump在内核学习时非常有用，如果我们需要了解内核运行状态或结构详情也可以使用kdump进行转储，后续使用Crash工具对照源码进行分析总结。

### 安装、配置

#### 安装kdump

检查kdump是否已经安装

```
rpm -q kexec-tools
```

如果没有安装，执行

```
yum install kexec-tools
```

评估需要多大的磁盘空间保存crash dump file，这感觉和物理内存大小一致。

```
[root@VM-0-8-centos crash]# makedumpfile --mem-usage /proc/kcore

TYPE		PAGES			EXCLUDABLE	DESCRIPTION
----------------------------------------------------------------------

ZERO		122466          	yes		Pages filled with zero
NON_PRI_CACHE	77566           	yes		Cache pages without private flag
PRI_CACHE	44617           	yes		Cache pages with private flag
USER		50293           	yes		User process pages
FREE		32981           	yes		Free pages
KERN_DATA	176823          	no		Dumpable kernel data 
```

#### 配置内核启动参数crashkernel

```
[root@VM-0-8-centos bpf-examples]# grubby --update-kernel=/boot/vmlinuz-5.14.0-86.el9.x86_64+debug --args=crashkernel=1G-2G:192M,2G-4G:320M,4G-32G:512M,32G-64G:1024M,64G-128G:2048M,128G-:4096M
```

系统重启后，可以在dmesg中查看相关信息：

```
[root@VM-0-8-centos ~]# dmesg -T | grep -i crash
[Mon Jun 27 15:10:44 2022] Command line: BOOT_IMAGE=(hd0,msdos1)/boot/vmlinuz-5.14.0-86.el9.x86_64+debug root=UUID=ceba5bd8-a35a-4599-9dee-6f3120630969 ro console=ttyS0,115200 console=tty0 panic=5 net.ifnames=0 biosdevname=0 intel_idle.max_cstate=1 intel_pstate=disable crashkernel=1G-2G:256M,2G-4G:320M,4G-32G:512M,32G-64G:1024M,64G-128G:2048M,128G-:4096M
[Mon Jun 27 15:10:44 2022] Reserving 256MB of memory at 1776MB for crashkernel (System RAM: 2047MB)
[Mon Jun 27 15:10:44 2022] Kernel command line: BOOT_IMAGE=(hd0,msdos1)/boot/vmlinuz-5.14.0-86.el9.x86_64+debug root=UUID=ceba5bd8-a35a-4599-9dee-6f3120630969 ro console=ttyS0,115200 console=tty0 panic=5 net.ifnames=0 biosdevname=0 intel_idle.max_cstate=1 intel_pstate=disable crashkernel=1G-2G:256M,2G-4G:320M,4G-32G:512M,32G-64G:1024M,64G-128G:2048M,128G-:4096M
```

#### Kdump的状态和配置

```
[root@VM-0-8-centos ~]# kdumpctl showmem
kdump: Reserved 256MB memory for crash kernel
[root@VM-0-8-centos ~]# kdumpctl start
kdump: Kdump already running: [WARNING]
[root@VM-0-8-centos ~]# kdumpctl status
kdump: Kdump is operational
[root@VM-0-8-centos crash]# systemctl is-active kdump
active
```

kdump输出vmcore保存路径：/etc/sysconfig/kdump。

```
KDUMP_SAVEDIR=”file:///var/crash”
```

查看内核的启动命令：

```
[root@VM-0-8-centos ~]# cat /proc/cmdline 
BOOT_IMAGE=(hd0,msdos1)/boot/vmlinuz-5.14.0-86.el9.x86_64+debug root=UUID=ceba5bd8-a35a-4599-9dee-6f3120630969 ro console=ttyS0,115200 console=tty0 panic=5 net.ifnames=0 biosdevname=0 intel_idle.max_cstate=1 intel_pstate=disable crashkernel=1G-2G:256M,2G-4G:320M,4G-32G:512M,32G-64G:1024M,64G-128G:2048M,128G-:4096M
```

查看crashkernel内存分配的地址空间

```
[root@VM-0-8-centos ~]# cat /proc/iomem | grep -i crash
  6f000000-7effffff : Crash kernel
```

### 测试验证

使用Magic SysRq来触发system crash。在测试之前先介绍下Magic SysRq其它一些很有用的值，其都输出在/var/log/messages

- `m` - dump information about memory allocation，导出内存分配的信息 （可以用/var/log/message 查看
- `t` - dump thread state information，导出线程状态信息
- `p` - dump current CPU registers and flags，导出当前CPU寄存器信息和标志位的信息
- `c` - intentionally crash the system (useful for forcing a disk or netdump)，故意让系统崩溃
- `s` - immediately sync all mounted filesystems
- `u` - immediately remount all filesystems read-only
- `b` - immediately reboot the machine
- `o` - immediately power off the machine (if configured and supported)
- `f` - start the Out Of Memory Killer (OOM)

执行一次system crash，然后系统重启了。

```
[root@VM-0-8-centos ~]# echo 1 > /proc/sys/kernel/sysrq
[root@VM-0-8-centos ~]# echo c > /proc/sysrq-trigger
Socket error Event: 32 Error: 10053.
Connection closing...Socket close.
```

个人感觉t, p还是挺有用的。

## Kexec

Kexec是一种可以从当前运行的内核引导另一内核的工具。可以准备好系统，以便在系统崩溃的情况下引导进入另一个内核。

该工具非常有用，例如：**保存崩溃内核的转储**。Kexec可以保留物理内存的内容，在生产内核发生故障后，捕获内核（在预留内存范围内运行的附加内核）会保留故障内核的状态。保存的映象可帮助后续分析。

### 组件介绍

最主要的就是/usr/sbin/kexec这个命令，可以通过两种方式使用Kexec装在内核：

- 将内核装载到某个生产内核的地址空间，已进行常规引导：

  ```
  kexec -l KERNEL_IMAGE
  ```

  可以稍后使用kexec -e引导到此内核。

- 将内核装载到预留的内存区域

  ```
  kexec -p KERNEL_IMAGE
  ```

  当系统崩溃时，会自动引导此内核。

所以前面配置的crashkerne指定的内存就是专门给捕获内核使用的，生产内核永远不会装载到此区域，这个参数必须追加到生产内核引导命令行。

## Crash分析

crash是一个用于分析内核转储文件的工具，一般配合kdump使用。

CentOS（RedHat）：crash /usr/lib/debug/lib/modules/<kernel>/vmlinux vmcore

在我的机器上执行命令：

```
crash /usr/lib/debug/usr/lib/modules/4.18.0-348.7.1.el8_5.x86_64/vmlinux /var/crash/127.0.0.1-2022-06-29-19:21:07/vmcore
```

在读取symbols之后会输出

```
      KERNEL: /usr/lib/debug/usr/lib/modules/4.18.0-348.7.1.el8_5.x86_64/vmlinux
    DUMPFILE: /var/crash/127.0.0.1-2022-06-29-19:21:07/vmcore  [PARTIAL DUMP]
        CPUS: 8
        DATE: Wed Jun 29 19:20:55 PDT 2022
      UPTIME: 00:01:38
LOAD AVERAGE: 0.56, 0.25, 0.10
       TASKS: 689
    NODENAME: localhost.localdomain
     RELEASE: 4.18.0-348.7.1.el8_5.x86_64
     VERSION: #1 SMP Wed Dec 22 13:25:12 UTC 2021
     MACHINE: x86_64  (4200 Mhz)
      MEMORY: 16 GB
       PANIC: "sysrq: SysRq : Trigger a crash"
         PID: 3370
     COMMAND: "zsh"
        TASK: ffff8d03f6c717c0  [THREAD_INFO: ffff8d03f6c717c0]
         CPU: 3
       STATE: TASK_RUNNING (SYSRQ)
```

输出说明：

TASKS：内核崩溃时，内存中有多少个任务在运行，Task是已经将指令加载到内存中。

PANIC：那种类型的crash发生在机器上。

PID：是哪个进程导致的crash。

### 命令

#### bt - backtrace

显示内核堆栈，如果没有具体参数指定，堆栈对应的是当前上下文的。

bt <pid>：列出相应进程的堆栈。

bt -f：列出当前堆栈每一帧中的数据。

bt -p：只打印panic的线程的内核栈。

堆栈每一行最右边是调用的地址。**可用sym或dis -s来查看具体代码**。

```
crash> bt
PID: 3370   TASK: ffff8d03f6c717c0  CPU: 3   COMMAND: "zsh"
 #0 [ffff9a6fc487fb98] machine_kexec at ffffffffb9e641ce
 #1 [ffff9a6fc487fbf0] __crash_kexec at ffffffffb9f9e67d
 #2 [ffff9a6fc487fcb8] crash_kexec at ffffffffb9f9f56d
 #3 [ffff9a6fc487fcd0] oops_end at ffffffffb9e2613d
 #4 [ffff9a6fc487fcf0] no_context at ffffffffb9e7562f
 #5 [ffff9a6fc487fd48] __bad_area_nosemaphore at ffffffffb9e7598c
 #6 [ffff9a6fc487fd90] do_page_fault at ffffffffb9e76267
 #7 [ffff9a6fc487fdc0] page_fault at ffffffffba80111e
    [exception RIP: sysrq_handle_crash+18]
    RIP: ffffffffba3affd2  RSP: ffff9a6fc487fe78  RFLAGS: 00010246
    RAX: ffffffffba3affc0  RBX: 0000000000000063  RCX: 0000000000000000
    RDX: 0000000000000000  RSI: ffff8d06eded6858  RDI: 0000000000000063
    RBP: 0000000000000004   R8: 00000000000006d6   R9: 000000000000002d
    R10: 0000000000000000  R11: ffff9a6fc487fd30  R12: 0000000000000000
    R13: 0000000000000000  R14: ffffffffbacaf240  R15: 0000000000000000
    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018
 #8 [ffff9a6fc487fe78] __handle_sysrq.cold.11 at ffffffffba3b0b68
 #9 [ffff9a6fc487fea8] write_sysrq_trigger at ffffffffba3b0a2b
#10 [ffff9a6fc487feb8] proc_reg_write at ffffffffba1b4359
#11 [ffff9a6fc487fed0] vfs_write at ffffffffba131915
#12 [ffff9a6fc487ff00] ksys_write at ffffffffba131b8f
#13 [ffff9a6fc487ff38] do_syscall_64 at ffffffffb9e042bb
#14 [ffff9a6fc487ff50] entry_SYSCALL_64_after_hwframe at ffffffffba8000ad
    RIP: 00007fc8a4c39648  RSP: 00007fffbd08cc98  RFLAGS: 00000246
    RAX: ffffffffffffffda  RBX: 0000000000000002  RCX: 00007fc8a4c39648
    RDX: 0000000000000002  RSI: 0000563d357b80c0  RDI: 0000000000000001
    RBP: 0000563d357b80c0   R8: 00007fc8a4f0d860   R9: 00007fc8a61a4b80
    R10: 000000000000000a  R11: 0000000000000246  R12: 00007fc8a4f0c6e0
    R13: 0000000000000002  R14: 00007fc8a4f07880  R15: 0000000000000002
    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b
```

#### dmesg - log

显示内核log_buf中的内容，也就是崩溃时的log。

ps 

显示内核崩溃时，当时系统中所有进程的状态

## 资料

- [Chapter 48. Installing and configuring kdump Red Hat Enterprise Linux 8 | Red Hat Customer Portal](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/system_design_guide/installing-and-configuring-kdump_system-design-guide)
- [kdump_usage_and_internals.pdf (linuxfound.org)](https://events.static.linuxfound.org/sites/events/files/slides/kdump_usage_and_internals.pdf)
- [Kexec 和 Kdump | 系统分析和微调指南 | SUSE Linux Enterprise Desktop 15 SP3](https://documentation.suse.com/zh-cn/sled/15-SP3/html/SLED-all/cha-tuning-kexec.html)
- [linux - centos 8: debuginfo-install can't find kernel-debuginfo package - Server Fault](https://serverfault.com/questions/1044899/centos-8-debuginfo-install-cant-find-kernel-debuginfo-package)

